# Are you tired of rewriting RecyclerView Adapters?
Me too! So I decided to create a Adapt in an effort to alleviate the pain.

# What is Adapt?
What if told you that creating adapters can be as simple as:

`private val adapter by adapter<ComicModel>(BR.comicModel, R.layout.comic_cell)`

Adapt is a DSL that attempts to standardize `RecyclerView.Adapter` creation by leveraging Android's
Data Binding framework.

# How do I use it?

## The simple case:

The DSL has several `adapter()`. For the most simple case, an adapter that handles one row type, the adapter can be defined using:

`private val adapter by adapter<ComicCell>(BR.comicModel, R.layout.comic_cell)`

`ComicModel` is a data class that implements `Identity`. `Identity` allows the consumer to determine how `areItemsTheSame()` will be computed.

`BR.comicModel` is the data binding variable that represents the model to be bound. This is automatically generated by Data Binding when you define the variable in the xml layout file:

```
<layout
        xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:app="http://schemas.android.com/apk/res-auto"
        xmlns:tools="http://schemas.android.com/tools">

    <data>
        <variable name="comicModel" type="me.emmano.androidmva.comics.mvvm.ComicModel"/>
    </data>
    ...
```

`R.layout.comic_cell` is the layout for the item that Data Binding will inflate.

### What if I need a click listener added to the whole row?

There is an override for `adapter()` that takes in a lambda that is applied as the click listener for the row:

`private val adapter by adapter<ComicModel>(BR.comicModel, R.layout.comic_cell){model-> //do something on click}`

### What if I need a click listener added to a particular item within the row?
There is an override for `adapter()` that takes in a lambda that gives access to the `ViewDataBinding` for the row's layout and the model:

`private val adapter by adapter<ComicCellBinding, ComicModel>(BR.comicModel, R.layout.comic_cell){binding, model-> //do something}`

## The not so simple case:
### What if my adapter needs to handle multiple row types?
There is an override for `adapter()` that allows the consumer to define an adapter in a "concise" manner:


```
fun TestFragment.adapter() = adapter<Model> {

    val TYPE_HEADER = 1
    val TYPE_CONTENT = 2

    onCreateViewHolder { parent, viewType ->
        when (viewType) {
            TYPE_HEADER -> holder<HeaderBinding, Header>(parent, R.layout.header, BR.header) {

                onBind { binding, header ->
                    binding.header.setOnClickListener {
                        Toast.makeText(
                            this@adapter.requireContext(),
                            header.title,
                            Toast.LENGTH_SHORT
                        ).show()
                    }
                }
            }

            TYPE_CONTENT -> holder<ContentBinding, Content>(parent, R.layout.content, BR.content) {

                onClick {
                    Toast.makeText(
                        this@adapter.requireContext(),
                        "Row Tapped",
                        Toast.LENGTH_SHORT
                    ).show()
                }

                onBind { binding, content ->
                    binding.content.setOnClickListener {
                        Toast.makeText(
                            this@adapter.requireContext(),
                            content.content,
                            Toast.LENGTH_SHORT
                        ).show()
                    }
                }

            }

            else -> throw IllegalStateException("ViewHolder not supported for itemViewType: $viewType")
        }
    }

    getViewTypes {
        when (it) {
            is Header -> TYPE_HEADER
            is Content -> TYPE_CONTENT
        }
    }
}
```
As you can see, `TestFragment.adapter()` is an extension function on the class that will use the adapter. This is done so the adapter definition can be extracted to its own file. Then the caller can get an instance of the adapter via:

`private val adapter by adapter()`

It is worth noting that `Header` and `Content` belong to the sealed class `Model` which implements `Identity`

`holder()` is a function that eases the creation of ViewHolders. It has support for a click listener that will be added to the whole row via `onClick()` and also for more complex bindings via `onBind()`

You can take a look at `TestFragment` for an example.

### If I have to move the adapter to its own file, what is the benefit of the DSL?
I would argue that having a standardize way to define adapters is a plus on its own. I would also argue
that it is true that the DSL has more value for simpler adapter types (adapters with one row type and a single click listener) since it greatly reduces the number of classes created when compared to a regular adapter implementation.


# What about testing?
Since all of the `ViewHolder` binding and creation logic is abstracted away (and tested), the consumer is only responsible for testing that the data is displayed and that click listeners have the desired behavior. Both of these can be tested via Robolectric and/or Espresso at the `Fragment`/`Activity` level:

```
class TestFragmentTest: RobolectricTest() {

        @Test
        fun `test adapter dsl`() {
            val scenario = launchFragmentInContainer<TestFragment>()
            scenario.onFragment {
                val recyclerView = it.requireView().findViewById<RecyclerView>(R.id.recycler)

                val headerViewHolder =
                    recyclerView.findViewHolderForLayoutPosition(0) ?: throw IllegalStateException()

                val header =
                    headerViewHolder.itemView.findViewById<TextView>(R.id.header)

                assertThat(header.text.toString(), equalTo("Title"))

                header.performClick()

                val titleText = ShadowToast.getTextOfLatestToast()

                assertThat(titleText, equalTo("Title"))

                val contentViewHolder =
                    recyclerView.findViewHolderForLayoutPosition(1) ?: throw IllegalStateException()

                contentViewHolder.itemView.performClick()

                val rowText = ShadowToast.getTextOfLatestToast()

                assertThat(rowText, equalTo("Row Tapped"))

                val content =
                    contentViewHolder.itemView.findViewById<TextView>(R.id.content)

                assertThat(content.text.toString(), equalTo("Content"))

            }

        }
    }
```

# How do I add Adapt to my project?
1. Make sure your project uses Data binding
2. Add `implement me.emmano:adapt:0.2.0` to your `build.gradle`
